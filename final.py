# -*- coding: utf-8 -*-
"""Final.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RQ5KRgxalym81zG2jzZ1stI1p_NAIeSC

#But
Ce notebook contient le code final à executer

# Importation des modules
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import math
from math import *
import scipy
import Levenshtein

"""On importe tous les autres documents de code"""

from outils_dessin import *
from arrangement_legitimite import *
from outils_courants import *
from outils_voronoi import *
#from resolution_optimisation_2d import *
from calcul_marges import *
from perturbations import *
from gestion_arrangements import *

def arrangement_optimal_triche(N_cyl, dimensions_carton, origine_carton, longueur, rayon, N_couche, axe):
  centres = np.random.normal(size =( N_cyl, 3), loc = [0,0,0], scale  = [5,5,5])
  arrangement = {'rayon' : rayon, 'longueur' : longueur, 'centres' : centres, 'dimensions du carton' : dimensions_carton, 'axe' : axe, 'origine du carton' : origine_carton}
  return arrangement

from logging import raiseExceptions
from logging import raiseExceptions
from logging import raiseExceptions
def conditionnement_monos(Nombre_De_Rouleaux = None, Dimensions_Du_Carton = None, Origine_Du_Carton=None, Longueur_minimale=None, Rayon_minimal=None, Nombre_de_Couches=None, a_mandrin_depassant=None, arrangemement_fourni = None, nom_fichier_bdd= 'Base de données des arrangements.json',  options_pertes  = None, cheatcode_active = False):
  '''
  Renvoie une règle de conditionnement, ainsi que les longueurs / rayons maximales pour chaque arrangement

   - Nombre_De_Rouleaux : Nombre de rouleaux à conditionner, Int
   - Dimensions_Du_Carton : Dimensions du carton (en mm), tableau de 3 floats
   - Longueur_minimale : Longueur minimale des rouleaux (en mm), float
   - Rayon_minimal : Rayon minimal des rouleaux (en mm), float
   - a_mandrin_depassant : Indique si le mandrin dépasse (interdit de le ranger de certaines manières), booleen
   - arrangement_fourni : Permet de choisir nous même le type d'arrangement parmi une liste de dictionnaires {nom ,  axe, nombre, centres, rayon, longueur, dimensions du carton, origine du carton, nombre de couches }
   - options_pertes : Dictionnaires des paramètres sur lesquels on peut jouer pour changer les pertes
  '''

  if cheatcode_active :
    arrangement_optimal = arrangement_optimal_triche
  if Nombre_De_Rouleaux == None :
    N_cyl = eval(input('Combien de rouleaux voulez vous ranger ?  ' ))
  else :
    N_cyl = N_cyl



  if Dimensions_Du_Carton == None :
    dimensions_carton = eval(input('quelles dimensions pour le carton ? '))
  else :
    dimensions_carton = Dimensions_Du_Carton


  origine_auto = False
  if Origine_Du_Carton == None :
    origine_carton = eval(input('Quelle est l origine du carton ?  '))
    if origine_carton == 'auto' :
      origine_auto = True
  else :
    origine_carton = Origine_Du_Carton



  if Longueur_minimale == None :
    longueur = eval(input('Quelle est la laize minimale acceptée pour rouleaux ?  '))
  else :
    longueur = Longueur_minimale



  if Rayon_minimal == None :
    rayon = eval(input('Quel est le rayon minimal accepté pour les rouleaux ?  '))
  else :
    rayon = Rayon_minimal



  if Nombre_de_Couches == None :
    N_couches = eval(input('Combien de couches voulez vous ?  '))
  else :
    N_couches = Nombre_de_Couches

  if a_mandrin_depassant == None :
    choix ='feur'
    while choix != 'oui' and choix != 'non' :
      choix = input('Est ce que le mandrin dépasse ? (oui/non) ?  ')
    if choix == 'oui' :
      a_mandrin_depassant = True
    else :
      a_mandrin_depassant = False

  if arrangemement_fourni == None:
    choix ='feur'
    while choix != 'oui' and choix != 'non' :
      choix = input('Voulez vous utiliser un arrangement existant ? (oui/non)  ')
    if choix == 'oui' :
      arrangemement_fourni = True
    else :
      arrangemement_fourni = False


  #on se donne une fonction pour voir si un arrangement est compatible avec les tailles et le nombre de rouleaux demandées
  def fonctionne(arrangement):
    rep = True
    if arrangement['rayon'] < rayon :
      rep = False
      print('pas le bon rayon')
    if arrangement['longueur'] < longueur :
      rep = False
      print('pas la bonne longueur')
    if arrangement['nombre'] < N_cyl :
      rep = False
      print('pas le bon nombre')
    if est_legitime(arrangement) == False :
      rep = False
      print('pas legitime')
      print(est_legitime.legitime_depassement)
      print(est_legitime.legitime_chevauchements)
      print(est_legitime.marges)
    return rep

  if arrangemement_fourni:#cas où l'utilisateur propose un arrangement parmi ceux existants
    flag = False
    while flag==False: #tant que l'arrangement proposé n'est pas compatible

      #le bloc suivant sert à reconnaître l'arrangement en fonction du nom tapé, et est capable de resister aux fautes de frappe tant qu'elle ne font pas trop ressembler un nom à un autre
      nom_arrangement = input('Quel arrangement existant voulez vous utiliser: ?  ')
      arrangement_source = ouvrir_arrangements(nom_arrangement)

      #on adapte l'arrangement "standard" à notre problème
      print('dilatation en cours ')
      arrangement = dilater_arrangement(arrangement_source, dimensions_carton, origine_carton, interaction = False) #si possible, range le rouleaux selon le même pattern que ceux de "arrangement".
      if fonctionne (arrangement) :
        print('cet arrangement fonctionne')
        choix = 'feur'
        while choix != 'oui' and choix != 'non' :
          choix = input('voulez vous garder cet arrangement ? (oui/non)  ')
          if choix == 'oui' :
            flag=True
          else :
            flag = False
      else :
        print('Attention, il y a un problème')
        print('cet arrangement ne convient pas')
        print('veuillez reessayer')


    #une fois qu'on a choisit notre configuration, on optimise au maximu rayon et laize
    if flag == True :
      arr_propose = optimiser_laize(optimiser_rayon(arrangement))
      rayon_opt = arr_propose['rayon']
      longueur_opt = arr_propose['longueur']

      print('le plus grand rayon pour cet arrangement est', rayon_opt)
      choix = 'feurfeur'
      while choix != 'oui' and choix != 'non' :
        choix = input('voulez vous garder ce rayon ? (oui/non)   ')
        if choix == 'oui' :
          arrangement['rayon'] = rayon_opt
        else :
          arrangement['rayon'] = eval(input('quel rayon voulez vous utiliser ?  '))

                                      
      print('la plus longue laize pour cet arrangement est', longueur_opt)
      choix ='feurfeur'
      while choix != 'oui' and choix != 'non' :
        choix = input('voulez vous garder cette laize ? (oui/non)   ')
        if choix == 'oui' :
          arrangement['longueur'] = longueur_opt
        else :
          arrangement['longueur'] = eval(input('quel laize voulez vous utiliser ?  '))

    actuel = arrangement
    rayon_propose = arrangement['rayon']
    longueur_propose = arrangement['longueur']
    axe_propose = arrangement['axe']



  else : #cas où l'utilisateur ne propose pas d'arrangement. Dans ce cas, on calcul l'arrangement optimal nous mêmes
    if a_mandrin_depassant : #cas où le mandrin dépasse
      est_legit = False
      axes = [[1,0,0],[0,1,0]]
      arrangement = arrangement_optimal(N_cyl, dimensions_carton, origine_carton, longueur, rayon, N_couches, axe = [1,0,0])
      if est_legitime(arrangement):
        est_legit = True
        axe = [1,0,0]

      #la partie qui suit calcul, pour chacun des axes de rotation possible pour le rouleau l'arrangement optimal et garde le meilleur au total
      #renvoie une erreur si ne parviens pas à trouver d'arrangement satisfaisant
      for axe_test in axes :
        arrangement_a_tester  = arrangement_optimal(N_cyl, dimensions_carton, origine_carton, longueur, rayon, N_couches, axe = axe_test)
        if est_legitime(arrangement_a_tester):
          if not((est_legit or est_legitime(arrangement))) or perte_total_2d(arrangement_a_tester, options_pertes) < perte_total_2d(arrangement, options_pertes)  :
            arrangement = arrangement_a_tester
            axe = axe_test


          est_legit = True
      if not est_legit :
        raise Exception('Aucun arrangement calulé ne convient')


      proposition = arrangement
      rayon_propose = rayon
      longueur_propose = longueur
      axe_propose = axe
      proposition_est_legitime = True
      #l'idée est que l'on va désormais, à partir de cet arrangement optimal, calculer les rayons et longueurs maximaux, puis essayer de voir si on peut pousser encore plus loin
      while proposition_est_legitime :
        proposition_est_legitime = False
        actuel = proposition
        marge(actuel)
        rayon_actuel = marge.rayon_maximal
        longueur_actuel = marge.longueur_maximale
        axe_actuel = axe_propose

        rayon_propose = 1.01 * rayon_actuel
        longueur_propose = longueur_actuel

        for axe_test in axes : #on calcule le nouvel arrangement optimal
          arrangement_a_tester = arrangement_optimal(N_cyl, dimensions_carton, origine_carton, longueur_propose, rayon_propose, N_couches, axe = [1,0,0])
          if est_legitime(arrangement_a_tester):
            if not((est_legit or est_legitime(arrangement ) )) or perte_total_2d(arrangement_a_tester, options_pertes) < perte_total_2d(actuel, options_pertes)  :
              arrangement = arrangement_a_tester
              axe = axe_test
              est_legit = True
              proposition_est_legitime = True

    else : #cas où le mandrin dépasse pas
      est_legit = False
      axes = [[1,0,0],[0,1,0],[0,0,1]]
      arrangement = arrangement_optimal(N_cyl, dimensions_carton, origine_carton, longueur, rayon,N_couches, axe = [1,0,0])
      if est_legitime(arrangement):
        est_legit = True
        axe = [1,0,0]

      #la partie qui suit calcul, pour chacun des axes de rotation possible pour le rouleau l'arrangement optimal et garde le meilleur au total
      #renvoie une erreur si ne parviens pas à trouver d'arrangement satisfaisant
      for axe_test in axes :
        arrangement_a_tester  = arrangement_optimal(N_cyl, dimensions_carton, origine_carton, longueur, rayon, N_couches, axe = axe_test)
        if est_legitime(arrangement_a_tester):
          if not((est_legit or est_legitime(arrangement))) or perte_total_2d(arrangement_a_tester, options_pertes) < perte_total_2d(arrangement, options_pertes)  :
            arrangement = arrangement_a_tester
            axe = axe_test

          est_legit = True

      if not est_legit :
        raise Exception('Aucun arrangement ne convient')


      proposition = arrangement
      rayon_propose = rayon
      longueur_propose = longueur
      axe_propose = axe
      proposition_est_legitime = True
      #l'idée est que l'on va désormais, à partir de cet arrangement optimal, calculer les rayons et longueurs maximaux, puis essayer de voir si on peut pousser encore plus loin
      while proposition_est_legitime :
        proposition_est_legitime = False
        actuel = proposition
        marge(actuel)
        rayon_actuel = marge.rayon_maximal
        longueur_actuel = marge.longueur_maximale
        axe_actuel = axe_propose
        actuel.update({'rayon': rayon_actuel, 'longueur' : longueur_actuel, 'axe' : axe_actuel})

        rayon_propose = 1.01 * rayon_actuel
        longueur_propose = longueur_actuel

        for axe_test in axes : #on calcule le nouvel arrangement optimal
          arrangement_a_tester =arrangement_optimal(N_cyl, dimensions_carton, origine_carton, longueur_propose, rayon_propose, N_couches, axe = [1,0,0])
          if est_legitime(arrangement_a_tester):
            if not((est_legit or est_legitime(arrangement ) )) or perte_total_2d(arrangement_a_tester, options_pertes) < perte_total_2d(actuel, options_pertes)  :
              arrangement = arrangement_a_tester
              axe = axe_test
              est_legit = True
              proposition_est_legitime = True


  # on propose d'enregistrer cette configuration
  reponse = 'feur'
  while(reponse != 'oui' and reponse != 'non'):
    reponse = input('Voulez vous enregistrer cette configuration ? (oui/non)')
    if reponse == 'oui':
      ajouter_arrangement(actuel, nom_fichier_bdd)
      return actuel
    elif reponse == 'non' :
      return actuel






